# -*- coding: utf-8 -*-
"""ML_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X2zfrsUBvd7MjlMXcmb7RCYduR6ZaTTr
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from csv import reader
import pandas as pd
from tensorflow import keras
from tensorflow.keras import applications
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import optimizers
from tensorflow.keras.models import Sequential, Model 
from tensorflow.keras.layers import *
from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler, TensorBoard, EarlyStopping
import os
from sklearn.model_selection import train_test_split
import tensorflow.keras.metrics as km
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import cohen_kappa_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import multilabel_confusion_matrix
from sklearn.metrics import classification_report

#build dataset for ML model training

X = []
Y = []

color_line = (255, 255, 255)
thickness = 10
img_height , img_width = 400, 100

previous_group = "empty"
image=np.zeros((1000,4000,3),np.uint8)
previous_point = (0,0)
frames_list = []

with open('ftir_metadata.csv', 'r') as read_obj_classes:
    csv_reader_classes = reader(read_obj_classes)
    header = next(csv_reader_classes)
    classes = []
    for row in csv_reader_classes:
      if row[0] not in classes:
        classes.append(row[0])

with open('ftir_library.csv', 'r') as read_obj:
    csv_reader = reader(read_obj)
    header = next(csv_reader)
    sortedlist = sorted(csv_reader, key=lambda row: int(row[3]))
    df=pd.read_csv("ftir_metadata.csv")

    # Iterate over each row in the csv using reader object
    for row in sortedlist:
        group = row[3]
        point = (int(float(row[0])), int(float(row[1])*1000))

        if previous_group == "empty":
            image=np.zeros((1000,4000,3),np.uint8)
            frames_list = []
            previous_group = group            
        elif (group != previous_group):
            y = [0]*len(classes)     
            val = df.iloc[int(previous_group)-1]['spectrum_identity']
            index = classes.index(val)
            y[index] = 1
            Y.append(y)

            print(previous_group)
            print(classes[index])
            plt.figure(figsize=(20, 20))
            plt.imshow(image, origin='lower')
            plt.show()

            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            image = cv2.resize(image, (img_height, img_width))
            frames_list.append(image)
            X.append(frames_list)

            frames_list = []
            image=np.zeros((1000,4000,3),np.uint8)

            previous_group = group
        else:           
            image = cv2.line(image, previous_point, point, color_line, thickness)  

        previous_point = point

    y = [0]*len(classes)     
    val = df.iloc[int(previous_group)-1]['spectrum_identity']
    index = classes.index(val)
    y[index] = 1
    Y.append(y)  

    print(previous_group)
    print(classes[index])
    plt.figure(figsize=(20, 20))
    plt.imshow(image, origin='lower')
    plt.show()

    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    image = cv2.resize(image, (img_height, img_width))        

    frames_list.append(image)
    X.append(frames_list)

X = np.asarray(X)
Y = np.asarray(Y)

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.30, shuffle=True, random_state=0)
 
model = Sequential()
model.add(ConvLSTM2D(filters = 64, kernel_size = (3, 3), return_sequences = False, data_format = "channels_last", input_shape = (1, 100, 400, 1)))
model.add(Dropout(0.2))
model.add(Flatten())
model.add(Dense(128, activation="relu"))
model.add(Dropout(0.3))
model.add(Dense(len(classes), activation = "softmax"))
 
model.summary()
 
opt = keras.optimizers.SGD(lr=0.001)
model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=["accuracy"])
 
earlystop = EarlyStopping(patience=5)
callbacks = [earlystop]
 
history = model.fit(x = X_train, y = y_train, epochs=15, batch_size = 8 , shuffle=True, validation_split=0.20, callbacks=callbacks)

# Calling `save('my_model')` creates a SavedModel folder `my_model`.
model.save("my_model")